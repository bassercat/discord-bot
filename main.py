# -*- coding: utf-8 -*-
"""ã€Œdoro_bot0516ã€çš„å‰¯æœ¬

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1r6M1FZUiCHDuT4QQQaxuQdnRwX24C_tV
"""

# å®‰è£éœ€è¦çš„å¥—ä»¶
#!pip install -q discord.py nest_asyncio

# åŒ¯å…¥æ¨¡çµ„
import nest_asyncio
import discord
from discord.ext import commands, tasks
import asyncio
from datetime import datetime
import pytz
import aiohttp
from io import BytesIO
import os
#==========æ“‹RANDER==========
from aiohttp import web
#==========æ“‹RANDER==========

# ç¦ç”¨èªéŸ³å¥—ä»¶è­¦å‘Š
discord.VoiceClient.warn_nacl = False

# ä¿®è£œ Colab çš„ asyncio loop å•é¡Œ
nest_asyncio.apply()

# è¨­å®š Intentsï¼ˆå…è¨±è®€å–è¨Šæ¯å…§å®¹ï¼‰
intents = discord.Intents.default()
intents.message_content = True

# å·¥å…·å‡½å¼ï¼šæ”¯æ´é »é“ IDï¼ˆint æˆ– strï¼‰æˆ–é »é“åç¨±ï¼ˆstrï¼‰
def get_channel_by_name_or_id(guild, identifier):
    if isinstance(identifier, int):
        return guild.get_channel(identifier)
    elif isinstance(identifier, str) and identifier.isdigit():
        return guild.get_channel(int(identifier))
    else:
        return discord.utils.get(guild.text_channels, name=identifier)

# ===== ğŸ› ï¸ è‡ªè¨‚è¨­å®šå€ ==============================
# å…è¨±ä½¿ç”¨æŒ‡ä»¤çš„æˆå“¡IDæ¸…å–®
ALLOWED_USER_IDS = [
    358124858552614912
]

T = True
F = False

A_ENABLED = T # æ­£å¼æœé–‹å•Ÿ True
B_ENABLED = T  # æ¸¬è©¦æœé—œé–‰ False

# ä¼ºæœå™¨ IDï¼ˆæ›¿æ›æˆä½ è‡ªå·±çš„ä¼ºæœå™¨IDï¼‰
A_GUILD_ID = 1333115184981479454  # ä¼ºæœå™¨A ID
B_GUILD_ID = 368417445565693953  # ä¼ºæœå™¨B ID

#BOTç‹€æ…‹
CUSTOM_ACTIVITY_TEXT = "è·Ÿå¡”ç¾…æœ‰é—œçš„å•é¡Œéº»ç…©è«‹å‚³ç§è¨Šï½"

#/s/eè¼¸å‡ºä¹‹é »é“ N
S_COMMAND_CHANNELS = {
    A_GUILD_ID: "now",  # ä¼ºæœå™¨Açš„é »é“åç¨±
    B_GUILD_ID: "g",  # ä¼ºæœå™¨Bçš„é »é“åç¨±
}

#åœ–ç‰‡è½‰å‚³é »é“è¨­å®šï¼šä¾†æºé »é“ID â†’ ç›®æ¨™é »é“ID
CHANNEL_MAP = {
    A_GUILD_ID: {
        "bot-to-åœ–ç‰‡åˆ†äº«": "åœ–ç‰‡åˆ†äº«",
        "bot-to-doroå°ˆå€": "doroå°ˆå€",
        "bot-to-now": "now"
    },
    B_GUILD_ID: {
        "a": "b",
        "c": "d",
        "e": "f",
    }
}

# æ¯æ—¥å®šæ™‚è¨Šæ¯æ–‡å­—ï¼ˆå°åŒ—æ™‚é–“ï¼‰å¯ç”¨:EMOJI:
DAILY_MESSAGE_TEXT = "123"

# æ¯æ—¥å®šæ™‚è¨Šæ¯ç™¼é€æ™‚é–“ï¼ˆ24å°æ™‚åˆ¶ï¼‰
DAILY_MESSAGE_HOUR = 23   # é è¨­æ™šä¸Š11é»
DAILY_MESSAGE_MINUTE = 0  # é è¨­0åˆ†

# æ˜¯å¦å•Ÿç”¨å®šæ™‚è¨Šæ¯åŠŸèƒ½ï¼ˆé è¨­ç‚º Falseï¼‰
ENABLE_DAILY_MESSAGE = False
# ==================================================

# å»ºç«‹æ©Ÿå™¨äºº
bot = commands.Bot(command_prefix='/', intents=intents)

#==========æ“‹RANDER==========
async def handle(request):
    return web.Response(text="I'm alive!")

async def start_webserver():
    app = web.Application()
    app.router.add_get('/', handle)
    runner = web.AppRunner(app)
    await runner.setup()
    site = web.TCPSite(runner, '0.0.0.0', 8080)  # ç›£è½0.0.0.0ï¼Œç«¯å£8080ï¼ˆRenderè¦æ±‚ï¼‰
    await site.start()
    print("Web server started on port 8080")
#==========æ“‹RANDER==========

#==========æ“‹RANDER==========
async def keep_alive_ping():
    await bot.wait_until_ready()
    while not bot.is_closed():
        try:
            for guild_id, channel_id in S_COMMAND_CHANNELS.items():
                guild = bot.get_guild(guild_id)
                if guild:
                    channel = guild.get_channel(channel_id)
                    if not channel:
                        # fallbackï¼šæ‰¾ä¸€å€‹æ–‡å­—é »é“
                        channel = next((ch for ch in guild.text_channels), None)
                    if channel:
                        async for _ in channel.history(limit=1):
                            pass  # fake request to keep alive
            print("ğŸŸ¢ Keep-alive ping åŸ·è¡ŒæˆåŠŸ")
        except Exception as e:
            print(f"âŒ Keep-alive ping ç™¼ç”ŸéŒ¯èª¤ï¼š{e}")
        await asyncio.sleep(600)  # æ¯ 10 åˆ†é˜
#==========æ“‹RANDER==========

# ç™½åå–®
def is_allowed_user():
    async def predicate(ctx):
        return ctx.author.id in ALLOWED_USER_IDS
    return commands.check(predicate)

# éœé»˜è™•ç†æ²’æœ‰æ¬Šé™éŒ¯èª¤ï¼ˆCheckFailureï¼‰
@bot.event
async def on_command_error(ctx, error):
    if isinstance(error, commands.CheckFailure):
        # æ²’æ¬Šé™å°±ä¸å›æ‡‰ä»»ä½•è¨Šæ¯
        return
    else:
        raise error

# æ¯æ—¥å®šæ™‚ä»»å‹™ï¼Œæ¯åˆ†é˜æª¢æŸ¥ä¸€æ¬¡
@tasks.loop(minutes=1)
async def daily_message_task():
    if not ENABLE_DAILY_MESSAGE:
        return

    tz = pytz.timezone('Asia/Taipei')
    now = datetime.now(tz)

    if now.hour == DAILY_MESSAGE_HOUR and now.minute == DAILY_MESSAGE_MINUTE:
        for guild_id, enabled in [(A_GUILD_ID, A_ENABLED), (B_GUILD_ID, B_ENABLED)]:
            if not enabled:
                continue
            guild = bot.get_guild(guild_id)
            if guild is None:
                continue
            channel_name_or_id = S_COMMAND_CHANNELS.get(guild_id)
            channel = get_channel_by_name_or_id(guild, channel_name_or_id)
            if channel:
                try:
                    # å˜—è©¦å°‡ :emoji_name: è‡ªå‹•è½‰ç‚º <:{name}:{id}>
                    content = DAILY_MESSAGE_TEXT
                    for emoji in guild.emojis:
                        tag = f":{emoji.name}:"
                        code = str(emoji)
                        content = content.replace(tag, code)
                    await channel.send(content)
                except Exception as e:
                    print(f"âŒ å®šæ™‚è¨Šæ¯ç™¼é€å¤±æ•—ï¼ˆ{guild.name}ï¼‰ï¼š{e}")

# ç•¶æ©Ÿå™¨äººå•Ÿå‹•æ™‚
@bot.event
async def on_ready():
    print(f'âœ… æ©Ÿå™¨äººå·²ä¸Šç·šï¼š{bot.user}')
    activity = discord.CustomActivity(name=CUSTOM_ACTIVITY_TEXT)
    await bot.change_presence(status=discord.Status.online, activity=activity)

    # âœ… å•Ÿå‹• keep-alive
    bot.loop.create_task(keep_alive_ping())
    
    # âœ… å•Ÿå‹•æ¯æ—¥å®šæ™‚ä»»å‹™ï¼ˆåªæœ‰åœ¨å•Ÿç”¨æ™‚ï¼‰
    if ENABLE_DAILY_MESSAGE and not daily_message_task.is_running():
        daily_message_task.start()

# æŒ‡ä»¤ï¼š/s <è¨Šæ¯> æˆ– /s <è¨Šæ¯ID> <å›è¦†å…§å®¹>
@bot.command()
@is_allowed_user()
async def s(ctx, *args):
    await ctx.message.delete()
    guild = ctx.guild
    if not guild:
        await ctx.send("âŒ ç„¡æ³•å–å¾—ä¼ºæœå™¨è³‡è¨Šã€‚")
        return

    # åˆ¤æ–·æ­¤ä¼ºæœå™¨æ˜¯å¦å•Ÿç”¨
    if (guild.id == A_GUILD_ID and not A_ENABLED) or (guild.id == B_GUILD_ID and not B_ENABLED):
        await ctx.send("âŒ æ­¤ä¼ºæœå™¨åŠŸèƒ½å°šæœªå•Ÿç”¨ã€‚")
        return

    channel_name_or_id = S_COMMAND_CHANNELS.get(guild.id)
    if not channel_name_or_id:
        await ctx.send("âŒ å°šæœªè¨­å®šæŒ‡ä»¤è¼¸å‡ºé »é“ã€‚")
        return

    channel = get_channel_by_name_or_id(guild, channel_name_or_id)
    if not channel:
        await ctx.send("âŒ æ‰¾ä¸åˆ°æŒ‡å®šçš„é »é“ã€‚")
        return

    if not args:
        await ctx.send("âŒ è«‹æä¾›è¨Šæ¯å…§å®¹ã€‚")
        return

    first_arg = args[0]
    rest_message = ' '.join(args[1:]) if len(args) > 1 else ''

    if first_arg.isdigit():
        try:
            target_msg = await channel.fetch_message(int(first_arg))
            if not rest_message:
                await ctx.send("âŒ è«‹æä¾›å›è¦†å…§å®¹ã€‚")
                return
            await target_msg.reply(rest_message)
        except Exception as e:
            await ctx.send(f"âŒ æ‰¾ä¸åˆ°è¨Šæ¯æˆ–å›è¦†å¤±æ•—ï¼š{e}")
    else:
        message = ' '.join(args)
        try:
            await channel.send(message)
        except Exception as e:
            await ctx.send(f"âŒ ç™¼é€å¤±æ•—ï¼š{e}")

# æŒ‡ä»¤ï¼š/e <è¨Šæ¯ID> ğŸ˜€â¤ï¸ï¼Œå¹«ç›®æ¨™é »é“å…§çš„è¨Šæ¯åŠ ä¸Šè¡¨æƒ…
@bot.command()
@is_allowed_user()
async def e(ctx, message_id: int, *emojis):
    await ctx.message.delete()
    guild = ctx.guild
    if not guild:
        return  # ç„¡ä¼ºæœå™¨ç’°å¢ƒä¸‹ç›´æ¥çµæŸ

    # åˆ¤æ–·æ­¤ä¼ºæœå™¨æ˜¯å¦å•Ÿç”¨
    if (guild.id == A_GUILD_ID and not A_ENABLED) or (guild.id == B_GUILD_ID and not B_ENABLED):
        return

    channel_name_or_id = S_COMMAND_CHANNELS.get(guild.id)
    if not channel_name_or_id:
        return

    channel = get_channel_by_name_or_id(guild, channel_name_or_id)
    if not channel:
        return  # æ‰¾ä¸åˆ°é »é“éœé»˜çµæŸ

    # å»ºç«‹åç¨±å°æ‡‰ emoji ç‰©ä»¶å­—å…¸ï¼Œæ–¹ä¾¿æŸ¥æ‰¾
    emoji_map = {e.name: e for e in guild.emojis}

    try:
        target_msg = await channel.fetch_message(message_id)
        for em in emojis:
            em_name = em.strip(':')
            emoji_obj = emoji_map.get(em_name)
            emoji_to_use = emoji_obj or em  # ä½¿ç”¨è‡ªè¨‚ emoji ç‰©ä»¶æˆ–åŸå§‹å­—ä¸²

            already_reacted = False
            for reaction in target_msg.reactions:
                # reaction.emoji æ˜¯ Emoji ç‰©ä»¶æˆ–å­—ä¸²
                if (emoji_obj and isinstance(reaction.emoji, discord.Emoji) and reaction.emoji.id == emoji_obj.id) or \
                   (not emoji_obj and str(reaction.emoji) == em):
                    async for user in reaction.users():
                        if user == bot.user:
                            already_reacted = True
                            break
                if already_reacted:
                    break

            if already_reacted:
                try:
                    await target_msg.remove_reaction(emoji_to_use, bot.user)
                except Exception as e:
                    print(f"âŒ ç„¡æ³•ç§»é™¤åæ‡‰ï¼š{e}")
            else:
                try:
                    await target_msg.add_reaction(emoji_to_use)
                except Exception as e:
                    print(f"âŒ ç„¡æ³•åŠ åæ‡‰ï¼š{e}")

    except Exception as e:
        print(f"âŒ å–å¾—è¨Šæ¯æˆ–åæ‡‰å‡ºéŒ¯ï¼š{e}")


# ç›£è½åœ–ç‰‡ä¸¦è½‰è²¼åˆ°æŒ‡å®šé »é“ï¼Œä¸”åˆªé™¤åŸå§‹è¨Šæ¯
@bot.event
async def on_message(message):
    if message.author.bot:
        return

    # æ’é™¤ä»¥ / é–‹é ­çš„æŒ‡ä»¤è¨Šæ¯ï¼Œä¸åšåœ–ç‰‡è½‰å‚³
    if message.content.startswith('/'):
        await bot.process_commands(message)
        return

    guild = message.guild
    if not guild:
        return

    # åˆ¤æ–·æ­¤ä¼ºæœå™¨æ˜¯å¦å•Ÿç”¨
    if (guild.id == A_GUILD_ID and not A_ENABLED) or (guild.id == B_GUILD_ID and not B_ENABLED):
        return

    guild_channel_map = CHANNEL_MAP.get(guild.id, {})
    # ç”¨ä¾†æºé »é“åç¨±æ‰¾åˆ°ç›®æ¨™é »é“åç¨±
    target_channel_name_or_id = guild_channel_map.get(message.channel.name)

    if target_channel_name_or_id:
        target_channel = get_channel_by_name_or_id(guild, target_channel_name_or_id)
        if target_channel:
            image_attachments = [
                att for att in message.attachments
                if any(att.filename.lower().endswith(ext) for ext in ['.jpg', '.jpeg', '.png', '.gif', '.webp'])
            ]

            files = []
            if image_attachments:
                async with aiohttp.ClientSession() as session:
                    for att in image_attachments[:10]:
                        async with session.get(att.url) as resp:
                            if resp.status == 200:
                                img_data = await resp.read()
                                file = discord.File(BytesIO(img_data), filename=att.filename)
                                files.append(file)

            # âœ… ä¸€èµ·ç™¼é€æ–‡å­—èˆ‡åœ–ç‰‡ï¼ˆå¦‚æœæœ‰ï¼‰
            if message.content.strip() or files:
                try:
                    await target_channel.send(content=message.content.strip() or None, files=files or None)
                except Exception as e:
                    print(f"âŒ è¨Šæ¯è½‰ç™¼å¤±æ•—ï¼š{e}")

            # åˆªé™¤åŸè¨Šæ¯
            try:
                await message.delete()
            except Exception as e:
                print(f"âŒ åŸè¨Šæ¯åˆªé™¤å¤±æ•—ï¼š{e}")

    await bot.process_commands(message)

# RANDERç’°å¢ƒè®Šæ•¸
TOKEN = os.getenv("DISCORD_TOKEN")

# main() å‡½å¼è£¡é¢åŠ é€™è¡ŒåŒæ™‚å•Ÿå‹•æ©Ÿå™¨äººè·Ÿweb server
async def main():
    # åŒæ™‚å•Ÿå‹•æ©Ÿå™¨äººè·Ÿweb server
    await asyncio.gather(
        bot.start(TOKEN),
        start_webserver()
    )

if __name__ == "__main__":
    asyncio.run(main())
