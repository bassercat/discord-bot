# -*- coding: utf-8 -*-
"""「doro_bot0516」的副本

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1r6M1FZUiCHDuT4QQQaxuQdnRwX24C_tV
"""

# 安裝需要的套件
#!pip install -q discord.py nest_asyncio

# 匯入模組
import nest_asyncio
import discord
from discord.ext import commands, tasks
import asyncio
from datetime import datetime
import pytz
import aiohttp
from io import BytesIO
import os
#==========擋RANDER==========
from aiohttp import web
#==========擋RANDER==========

# 禁用語音套件警告
discord.VoiceClient.warn_nacl = False

# 修補 Colab 的 asyncio loop 問題
nest_asyncio.apply()

# 設定 Intents（允許讀取訊息內容）
intents = discord.Intents.default()
intents.message_content = True

# 工具函式：支援頻道 ID（int 或 str）或頻道名稱（str）
def get_channel_by_name_or_id(guild, identifier):
    if isinstance(identifier, int):
        return guild.get_channel(identifier)
    elif isinstance(identifier, str) and identifier.isdigit():
        return guild.get_channel(int(identifier))
    else:
        return discord.utils.get(guild.text_channels, name=identifier)

# ===== 🛠️ 自訂設定區 ==============================
# 允許使用指令的成員ID清單
ALLOWED_USER_IDS = [
    358124858552614912
]

T = True
F = False

A_ENABLED = T # 正式服開啟 True
B_ENABLED = T  # 測試服關閉 False

# 伺服器 ID（替換成你自己的伺服器ID）
A_GUILD_ID = 1333115184981479454  # 伺服器A ID
B_GUILD_ID = 368417445565693953  # 伺服器B ID

#BOT狀態
CUSTOM_ACTIVITY_TEXT = "跟塔羅有關的問題麻煩請傳私訊～"

#/s/e輸出之頻道 N
S_COMMAND_CHANNELS = {
    A_GUILD_ID: "now",  # 伺服器A的頻道名稱
    B_GUILD_ID: "g",  # 伺服器B的頻道名稱
}

#圖片轉傳頻道設定：來源頻道ID → 目標頻道ID
CHANNEL_MAP = {
    A_GUILD_ID: {
        "bot-to-圖片分享": "圖片分享",
        "bot-to-doro專區": "doro專區",
        "bot-to-now": "now"
    },
    B_GUILD_ID: {
        "a": "b",
        "c": "d",
        "e": "f",
    }
}

# 每日定時訊息文字（台北時間）可用:EMOJI:
DAILY_MESSAGE_TEXT = "123"

# 每日定時訊息發送時間（24小時制）
DAILY_MESSAGE_HOUR = 23   # 預設晚上11點
DAILY_MESSAGE_MINUTE = 0  # 預設0分

# 是否啟用定時訊息功能（預設為 False）
ENABLE_DAILY_MESSAGE = False
# ==================================================

# 建立機器人
bot = commands.Bot(command_prefix='/', intents=intents)

#==========擋RANDER==========
async def handle(request):
    return web.Response(text="I'm alive!")

async def start_webserver():
    app = web.Application()
    app.router.add_get('/', handle)
    runner = web.AppRunner(app)
    await runner.setup()
    site = web.TCPSite(runner, '0.0.0.0', 8080)  # 監聽0.0.0.0，端口8080（Render要求）
    await site.start()
    print("Web server started on port 8080")
#==========擋RANDER==========

#==========擋RANDER==========
async def keep_alive_ping():
    await bot.wait_until_ready()
    while not bot.is_closed():
        try:
            for guild_id, channel_id in S_COMMAND_CHANNELS.items():
                guild = bot.get_guild(guild_id)
                if guild:
                    channel = guild.get_channel(channel_id)
                    if not channel:
                        # fallback：找一個文字頻道
                        channel = next((ch for ch in guild.text_channels), None)
                    if channel:
                        async for _ in channel.history(limit=1):
                            pass  # fake request to keep alive
            print("🟢 Keep-alive ping 執行成功")
        except Exception as e:
            print(f"❌ Keep-alive ping 發生錯誤：{e}")
        await asyncio.sleep(600)  # 每 10 分鐘
#==========擋RANDER==========

# 白名單
def is_allowed_user():
    async def predicate(ctx):
        return ctx.author.id in ALLOWED_USER_IDS
    return commands.check(predicate)

# 靜默處理沒有權限錯誤（CheckFailure）
@bot.event
async def on_command_error(ctx, error):
    if isinstance(error, commands.CheckFailure):
        # 沒權限就不回應任何訊息
        return
    else:
        raise error

# 每日定時任務，每分鐘檢查一次
@tasks.loop(minutes=1)
async def daily_message_task():
    if not ENABLE_DAILY_MESSAGE:
        return

    tz = pytz.timezone('Asia/Taipei')
    now = datetime.now(tz)

    if now.hour == DAILY_MESSAGE_HOUR and now.minute == DAILY_MESSAGE_MINUTE:
        for guild_id, enabled in [(A_GUILD_ID, A_ENABLED), (B_GUILD_ID, B_ENABLED)]:
            if not enabled:
                continue
            guild = bot.get_guild(guild_id)
            if guild is None:
                continue
            channel_name_or_id = S_COMMAND_CHANNELS.get(guild_id)
            channel = get_channel_by_name_or_id(guild, channel_name_or_id)
            if channel:
                try:
                    # 嘗試將 :emoji_name: 自動轉為 <:{name}:{id}>
                    content = DAILY_MESSAGE_TEXT
                    for emoji in guild.emojis:
                        tag = f":{emoji.name}:"
                        code = str(emoji)
                        content = content.replace(tag, code)
                    await channel.send(content)
                except Exception as e:
                    print(f"❌ 定時訊息發送失敗（{guild.name}）：{e}")

# 當機器人啟動時
@bot.event
async def on_ready():
    print(f'✅ 機器人已上線：{bot.user}')
    activity = discord.CustomActivity(name=CUSTOM_ACTIVITY_TEXT)
    await bot.change_presence(status=discord.Status.online, activity=activity)

    # ✅ 啟動 keep-alive
    bot.loop.create_task(keep_alive_ping())
    
    # ✅ 啟動每日定時任務（只有在啟用時）
    if ENABLE_DAILY_MESSAGE and not daily_message_task.is_running():
        daily_message_task.start()

# 指令：/s <訊息> 或 /s <訊息ID> <回覆內容>
@bot.command()
@is_allowed_user()
async def s(ctx, *args):
    await ctx.message.delete()
    guild = ctx.guild
    if not guild:
        await ctx.send("❌ 無法取得伺服器資訊。")
        return

    # 判斷此伺服器是否啟用
    if (guild.id == A_GUILD_ID and not A_ENABLED) or (guild.id == B_GUILD_ID and not B_ENABLED):
        await ctx.send("❌ 此伺服器功能尚未啟用。")
        return

    channel_name_or_id = S_COMMAND_CHANNELS.get(guild.id)
    if not channel_name_or_id:
        await ctx.send("❌ 尚未設定指令輸出頻道。")
        return

    channel = get_channel_by_name_or_id(guild, channel_name_or_id)
    if not channel:
        await ctx.send("❌ 找不到指定的頻道。")
        return

    if not args:
        await ctx.send("❌ 請提供訊息內容。")
        return

    first_arg = args[0]
    rest_message = ' '.join(args[1:]) if len(args) > 1 else ''

    if first_arg.isdigit():
        try:
            target_msg = await channel.fetch_message(int(first_arg))
            if not rest_message:
                await ctx.send("❌ 請提供回覆內容。")
                return
            await target_msg.reply(rest_message)
        except Exception as e:
            await ctx.send(f"❌ 找不到訊息或回覆失敗：{e}")
    else:
        message = ' '.join(args)
        try:
            await channel.send(message)
        except Exception as e:
            await ctx.send(f"❌ 發送失敗：{e}")

# 指令：/e <訊息ID> 😀❤️，幫目標頻道內的訊息加上表情
@bot.command()
@is_allowed_user()
async def e(ctx, message_id: int, *emojis):
    await ctx.message.delete()
    guild = ctx.guild
    if not guild:
        return  # 無伺服器環境下直接結束

    # 判斷此伺服器是否啟用
    if (guild.id == A_GUILD_ID and not A_ENABLED) or (guild.id == B_GUILD_ID and not B_ENABLED):
        return

    channel_name_or_id = S_COMMAND_CHANNELS.get(guild.id)
    if not channel_name_or_id:
        return

    channel = get_channel_by_name_or_id(guild, channel_name_or_id)
    if not channel:
        return  # 找不到頻道靜默結束

    # 建立名稱對應 emoji 物件字典，方便查找
    emoji_map = {e.name: e for e in guild.emojis}

    try:
        target_msg = await channel.fetch_message(message_id)
        for em in emojis:
            em_name = em.strip(':')
            emoji_obj = emoji_map.get(em_name)
            emoji_to_use = emoji_obj or em  # 使用自訂 emoji 物件或原始字串

            already_reacted = False
            for reaction in target_msg.reactions:
                # reaction.emoji 是 Emoji 物件或字串
                if (emoji_obj and isinstance(reaction.emoji, discord.Emoji) and reaction.emoji.id == emoji_obj.id) or \
                   (not emoji_obj and str(reaction.emoji) == em):
                    async for user in reaction.users():
                        if user == bot.user:
                            already_reacted = True
                            break
                if already_reacted:
                    break

            if already_reacted:
                try:
                    await target_msg.remove_reaction(emoji_to_use, bot.user)
                except Exception as e:
                    print(f"❌ 無法移除反應：{e}")
            else:
                try:
                    await target_msg.add_reaction(emoji_to_use)
                except Exception as e:
                    print(f"❌ 無法加反應：{e}")

    except Exception as e:
        print(f"❌ 取得訊息或反應出錯：{e}")


# 監聽圖片並轉貼到指定頻道，且刪除原始訊息
@bot.event
async def on_message(message):
    if message.author.bot:
        return

    # 排除以 / 開頭的指令訊息，不做圖片轉傳
    if message.content.startswith('/'):
        await bot.process_commands(message)
        return

    guild = message.guild
    if not guild:
        return

    # 判斷此伺服器是否啟用
    if (guild.id == A_GUILD_ID and not A_ENABLED) or (guild.id == B_GUILD_ID and not B_ENABLED):
        return

    guild_channel_map = CHANNEL_MAP.get(guild.id, {})
    # 用來源頻道名稱找到目標頻道名稱
    target_channel_name_or_id = guild_channel_map.get(message.channel.name)

    if target_channel_name_or_id:
        target_channel = get_channel_by_name_or_id(guild, target_channel_name_or_id)
        if target_channel:
            image_attachments = [
                att for att in message.attachments
                if any(att.filename.lower().endswith(ext) for ext in ['.jpg', '.jpeg', '.png', '.gif', '.webp'])
            ]

            files = []
            if image_attachments:
                async with aiohttp.ClientSession() as session:
                    for att in image_attachments[:10]:
                        async with session.get(att.url) as resp:
                            if resp.status == 200:
                                img_data = await resp.read()
                                file = discord.File(BytesIO(img_data), filename=att.filename)
                                files.append(file)

            # ✅ 一起發送文字與圖片（如果有）
            if message.content.strip() or files:
                try:
                    await target_channel.send(content=message.content.strip() or None, files=files or None)
                except Exception as e:
                    print(f"❌ 訊息轉發失敗：{e}")

            # 刪除原訊息
            try:
                await message.delete()
            except Exception as e:
                print(f"❌ 原訊息刪除失敗：{e}")

    await bot.process_commands(message)

# RANDER環境變數
TOKEN = os.getenv("DISCORD_TOKEN")

# main() 函式裡面加這行同時啟動機器人跟web server
async def main():
    # 同時啟動機器人跟web server
    await asyncio.gather(
        bot.start(TOKEN),
        start_webserver()
    )

if __name__ == "__main__":
    asyncio.run(main())
